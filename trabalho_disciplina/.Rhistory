# Criando a visualização para análise de correlação dos indicadores da variável latente tutoria
support_pca = nipals(data_education[,10:13])
plot(support_pca, main = "Indicadores da variável latente tutoria (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente valor
cor(data_education[,14:17])
# Criando a visualização para análise de correlação dos indicadores da variável latente valor
support_pca = nipals(data_education[,14:17])
plot(support_pca, main = "Indicadores da variável latente valor (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente satisfação
cor(data_education[,18:20])
# Criando a visualização para análise de correlação dos indicadores da variável latente satisfação
support_pca = nipals(data_education[,18:20])
plot(support_pca, main = "Indicadores da variável latente satisfacao (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente lealdade
cor(data_education[,21:24])
# Criando a visualização para análise de correlação dos indicadores da variável latente lealdade
support_pca = nipals(data_education[,21:24])
plot(support_pca, main = "Indicadores da variável latente lealdade (círculo de correlação)", cex.main = 1)
install.packages("plsdepot")
support_pca = nipals(data_education [,2:5])
plot(support_pca, main = "Indicadores da variável latente suporte (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente aconselhamento
cor(data_education[,6:9])
# Criando a visualização para análise de correlação dos indicadores da variável latente suporte
support_pca = nipals(data_education[,6:9])
plot(support_pca, main = "Indicadores da variável latente aconselhamento (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente tutoria
cor(data_education[,10:13])
# Criando a visualização para análise de correlação dos indicadores da variável latente tutoria
support_pca = nipals(data_education[,10:13])
plot(support_pca, main = "Indicadores da variável latente tutoria (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente valor
cor(data_education[,14:17])
# Criando a visualização para análise de correlação dos indicadores da variável latente valor
support_pca = nipals(data_education[,14:17])
plot(support_pca, main = "Indicadores da variável latente valor (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente satisfação
cor(data_education[,18:20])
# Criando a visualização para análise de correlação dos indicadores da variável latente satisfação
support_pca = nipals(data_education[,18:20])
plot(support_pca, main = "Indicadores da variável latente satisfacao (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente lealdade
cor(data_education[,21:24])
# Criando a visualização para análise de correlação dos indicadores da variável latente lealdade
support_pca = nipals(data_education[,21:24])
plot(support_pca, main = "Indicadores da variável latente lealdade (círculo de correlação)", cex.main = 1)
library("plsdepot")
# Criando a visualização para análise de correlação dos indicadores da variável latente suporte
support_pca = nipals(data_education [,2:5])
plot(support_pca, main = "Indicadores da variável latente suporte (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente aconselhamento
cor(data_education[,6:9])
# Criando a visualização para análise de correlação dos indicadores da variável latente suporte
support_pca = nipals(data_education[,6:9])
plot(support_pca, main = "Indicadores da variável latente aconselhamento (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente tutoria
cor(data_education[,10:13])
# Criando a visualização para análise de correlação dos indicadores da variável latente tutoria
support_pca = nipals(data_education[,10:13])
plot(support_pca, main = "Indicadores da variável latente tutoria (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente valor
cor(data_education[,14:17])
# Criando a visualização para análise de correlação dos indicadores da variável latente valor
support_pca = nipals(data_education[,14:17])
plot(support_pca, main = "Indicadores da variável latente valor (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente satisfação
cor(data_education[,18:20])
# Criando a visualização para análise de correlação dos indicadores da variável latente satisfação
support_pca = nipals(data_education[,18:20])
plot(support_pca, main = "Indicadores da variável latente satisfacao (círculo de correlação)", cex.main = 1)
# Calculando a correlação entre os indicadores que compõe a variável latente lealdade
cor(data_education[,21:24])
# Criando a visualização para análise de correlação dos indicadores da variável latente lealdade
support_pca = nipals(data_education[,21:24])
plot(support_pca, main = "Indicadores da variável latente lealdade (círculo de correlação)", cex.main = 1)
cor(data_education[,6:9])
cor(data_education[,10:13])
support_pca = nipals(data_education[,10:13])
cor(data_education[,14:17])
cor(data_education[,18:20])
cor(data_education[,21:24])
v_advising = c(0,0,1,0,1,0)
v_tutoring = c(0,0,1,0,1,0)
v_value = c(0,0,0,0,1,0)
v_support = c(0,0,1,0,1,0)
v_satisfaction = c(0,0,0,0,0,1)
v_loyalty = c(0,0,0,0,0,0)
v_advising = c(0,0,1,0,1,0)
v_tutoring = c(0,0,1,0,1,0)
v_value = c(0,0,0,0,1,0)
v_support = c(0,0,1,0,1,0)
v_satisfaction = c(0,0,0,0,0,1)
v_loyalty = c(0,0,0,0,0,0)
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
model_path
innerplot(model_path, box.size = 0.1)
install.packages("innerplot")
library("innerplot")
install.packages("innerplot")
version
R.version.string
install.packages("innerplot")
install.packages("plspm")
library("plspm")
innerplot(model_path)
# Criando os vetores de caminho para cada variável latente do modelo
v_advising = c(0,0,0,0,0,0)
v_tutoring = c(0,0,0,0,0,0)
v_value = c(1,1,0,1,0,0)
v_support = c(0,0,0,0,0,0)
v_satisfaction = c(1,1,1,1,0,0)
v_loyalty = c(0,0,0,0,1,0)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
innerplot(model_path)
innerplot(model_path,box.size = 0.1)
innerplot(model_path,box.size = 0.1)
# definição dos indicadores
model_blocks = list(1:4, 5:8, 9:12, 13:16, 17:19, 20:23)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
edu_modes = rep("A", 6)
#modelo de equações estruturais
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
model_modes = rep("A", 6)
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
model_blocks = list(1:4, 5:8, 9:12, 13:16, 17:19, 20:23)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
#modelo de equações estruturais
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
# Criando os vetores de caminho para cada variável latente do modelo
v_advising = c(0,0,0,0,0,0)
v_tutoring = c(0,0,0,0,0,0)
v_value = c(1,1,0,1,0,0)
v_support = c(0,0,0,0,0,0)
v_satisfaction = c(1,1,1,1,0,0)
v_loyalty = c(0,0,0,0,1,0)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
# install.packages("plspm")
#library("plspm")
#innerplot(model_path,box.size = 0.1)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
#modelo de equações estruturais
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
data_education_2 <- data_education
data_education_2$num <- NULL
education_pls = plspm(data_education_2, model_path, model_blocks, modes = model_modes)
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
education_pls = plspm(data_education_2, model_path, model_blocks, modes = model_modes)
View(model_path)
View(model_path)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(v_advising,v_tutoring,v_value, v_support, v_satisfaction,v_loyalty)
colnames(model_path) = rownames(model_path)
# install.packages("plspm")
#library("plspm")
#innerplot(model_path,box.size = 0.1)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
#modelo de equações estruturais
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
Support = c(0, 0, 0, 0, 0, 0)
Advising = c(0, 0, 0, 0, 0, 0)
Tutoring = c(0, 0, 0, 0, 0, 0)
Value = c(1, 1, 1, 0, 0, 0)
Satisfaction = c(1, 1, 1, 1, 0, 0)
Loyalty = c(0, 0, 0, 0, 1, 0)
View(data_education_2)
Support = c(0, 0, 0, 0, 0, 0)
Advising = c(0, 0, 0, 0, 0, 0)
Tutoring = c(0, 0, 0, 0, 0, 0)
Value = c(1, 1, 1, 0, 0, 0)
Satisfaction = c(1, 1, 1, 1, 0, 0)
Loyalty = c(0, 0, 0, 0, 1, 0)
edu_path = rbind(Support, Advising, Tutoring, Value, Satisfaction, Loyalty)
colnames(edu_path) = rownames(edu_path)
# outer model
edu_blocks = list(1:4, 5:8, 9:12, 13:16, 17:19, 20:23)
# modes (reflective blocks)
edu_modes = rep("A", 6)
edu_pls1 = plspm(data_education_2, edu_path, edu_blocks, modes = edu_modes)
# Criando os vetores de caminho para cada variável latente do modelo
Support = c(0, 0, 0, 0, 0, 0)
Advising = c(0, 0, 0, 0, 0, 0)
Tutoring = c(0, 0, 0, 0, 0, 0)
Value = c(1, 1, 1, 0, 0, 0)
Satisfaction = c(1, 1, 1, 1, 0, 0)
Loyalty = c(0, 0, 0, 0, 1, 0)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(Support, Advising, Tutoring, Value, Satisfaction, Loyalty)
colnames(model_path) = rownames(model_path)
# install.packages("plspm")
#library("plspm")
#innerplot(model_path,box.size = 0.1)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
#modelo de equações estruturais
education_pls = plspm(data_education, model_path, model_blocks, modes = model_modes)
Loyalty = c(0, 0, 0, 0, 1, 0)
summary(education_pls)
# Criando os vetores de caminho para cada variável latente do modelo
Support = c(0, 0, 0, 0, 0, 0)
Advising = c(0, 0, 0, 0, 0, 0)
Tutoring = c(0, 0, 0, 0, 0, 0)
Value = c(1, 1, 1, 0, 0, 0)
Satisfaction = c(1, 1, 1, 1, 0, 0)
Loyalty = c(0, 0, 0, 0, 1, 0)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(Support, Advising, Tutoring, Value, Satisfaction, Loyalty)
colnames(model_path) = rownames(model_path)
# install.packages("plspm")
#library("plspm")
innerplot(model_path,box.size = 0.1)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
#análise da qualidade do modelo
education_pls$unidim
#exibindo as carcas nas variáveis latentes
plot(education_pls, what = "loadings")
# Criando o indicador de apreciação
data_education$sup.appre = 8 - data_education$sup.under
# Criando o indicador de honrado
data_education$loy.pleas = 8 - data_education$loy.asha
# nova configuração dos indicadores
model_blocks = list(c(2,28,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,29,24)
# nova configuração dos indicadores
model_blocks_2 = list(c(2,28,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,29,24))
# novo modelo de equações estruturais
education_pls_2 = plspm(data_education, model_path, model_blocks_2, modes = model_modes)
# nova configuração dos indicadores
model_blocks_2 = list(c(2,28,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,29,24))
# novo modelo de equações estruturais
education_pls_2 = plspm(data_education, model_path, model_blocks_2, modes = model_modes)
#exibindo as carcas nas variáveis latentes
plot(education_pls_2, what = "loadings")
education_pls_2$unidim
#avaliando a carga e comunalidade de cada indicador
education_pls_2$outer_model
# nova configuração removendo os indicadores honrado e apreciação
model_blocks_2 = list(c(2,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,24))
# nova configuração removendo os indicadores honrado e apreciação
model_blocks_3 = list(c(2,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,24))
# modelo final
education_pls_3 = plspm(data_education, model_path, model_blocks_3, modes = model_modes)
education_pls_3$unidim
#exibindo as carcas nas variáveis latentes
plot(education_pls_3, what = "loadings")
# avaliando a carga e comunalidade de cada indicador
education_pls_3$outer_model
plot(edu_pls3, arr.pos = 0.35)
plot(education_pls_3, arr.pos = 0.35)
# análise do modelo estrutural
education_pls_3$inner_summary
# indicador de predição do modelo
education_pls_3$gof
edu_val = plspm(data_education, model_path, model_blocks_3, modes = model_modes,
boot.val = TRUE, br = 2000)
edu_val$boot$paths
# Carregando os dados do arquivo csv na variável data_education
data_education <- read.csv2("education.csv", sep=",")
# Calculando a correlação entre os indicadores que compõe a variável latente tutoria
cor(data_education[,10:13])
support_pca = nipals(data_education[,10:13])
plot(support_pca, main = "Indicadores da variável latente tutoria (círculo de correlação)", cex.main = 1)
# Carregando a biblioteca de análise de componentes principais
library("plsdepot")
# Calculando a correlação entre os indicadores que compõe a variável latente tutoria
cor(data_education[,10:13])
# Criando a visualização para análise de correlação dos indicadores da variável latente tutoria
support_pca = nipals(data_education[,10:13])
plot(support_pca, main = "Indicadores da variável latente tutoria (círculo de correlação)", cex.main = 1)
# Criando os vetores de caminho para cada variável latente do modelo
Support = c(0, 0, 0, 0, 0, 0)
Advising = c(0, 0, 0, 0, 0, 0)
Tutoring = c(0, 0, 0, 0, 0, 0)
Value = c(1, 1, 1, 0, 0, 0)
Satisfaction = c(1, 1, 1, 1, 0, 0)
Loyalty = c(0, 0, 0, 0, 1, 0)
# Definindo a matriz de direcionamento do modelo
model_path = rbind(Support, Advising, Tutoring, Value, Satisfaction, Loyalty)
colnames(model_path) = rownames(model_path)
# nova configuração removendo os indicadores honrado e apreciação
model_blocks_3 = list(c(2,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,24))
# modelo final
education_pls_3 = plspm(data_education, model_path, model_blocks_3, modes = model_modes)
library("plspm", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
# nova configuração removendo os indicadores honrado e apreciação
model_blocks_3 = list(c(2,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,24))
# modelo final
education_pls_3 = plspm(data_education, model_path, model_blocks_3, modes = model_modes)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
# definição dos indicadores
model_blocks = list(2:5, 6:9, 10:13, 14:17, 18:20, 21:24)
# definição do tipo de relação dos indicadores com as variáveis latentes - reflexivo - os indicadores geram o construto
model_modes = rep("A", 6)
# nova configuração removendo os indicadores honrado e apreciação
model_blocks_3 = list(c(2,4,5), 6:9, 10:13, 14:17, 18:20, c(21,22,24))
# modelo final
education_pls_3 = plspm(data_education, model_path, model_blocks_3, modes = model_modes)
# avaliando a carga cruzada
education_pls_3$crossloadings
# modelo final com as cargas
plot(education_pls_3, arr.pos = 0.35)
# modelo final com as cargas
plot(education_pls_3, arr.pos = 0.5)
plot(education_pls_3, arr.pos = 0.25)
# modelo final com as cargas
plot(education_pls_3, arr.pos = 0.25)
plot(education_pls_3, arr.pos = 0.25)
plot(education_pls_3, arr.pos = 0.25)
# modelo final com as cargas
plot(education_pls_3, arr.pos = 0.35)
set.seed(1) #definição de semente
Q = runif(500,8000,12000) #distribuição uniforme: tamanho amostra, mínimo, máximo
hist(Q,nclass=10) #histograma: variável, número de classes~
CV = rnorm(500,7,2)
CV = ifelse(CV<=1,1,CV)
P = rnorm(500,10,2)
P = ifelse(P<=1,1,P)
CF = 5000
L = Q*P - (Q*CV+CF)
hist(L,nclass=10)
contagem = ifelse(L<0,1,0)
sum(contagem)
prob_negativo = sum(contagem)/length(L)
prob_negativo
set.seed(1) #definição de semente
Q = runif(1000,8000,12000) #distribuição uniforme: tamanho amostra, mínimo, máximo
hist(Q,nclass=10) #histograma: variável, número de classes~
CV = rnorm(1000,7,2)
CV = ifelse(CV<=1,1,CV)
P = rnorm(1000,10,2)
P = ifelse(P<=1,1,P)
CF = 5000
L = Q*P - (Q*CV+CF)
hist(L,nclass=10)
contagem = ifelse(L<0,1,0)
sum(contagem)
prob_negativo = sum(contagem)/length(L)
prob_negativo
set.seed(1) #definição de semente
Q = runif(1000,8000,12000) #distribuição uniforme: tamanho amostra, mínimo, máximo
hist(Q,nclass=10) #histograma: variável, número de classes~
CV = rnorm(1000,7,2)
CV = ifelse(CV<=1,1,CV)
CV = ifelse(CV>=10,10,CV)
hist(CV,nclass=10)
P = rnorm(1000,10,2)
P = ifelse(P<=3.5,3.5,P)
hist(P,nclass=10)
hist(CV,nclass=10)
CF = 5000
L = Q*P - (Q*CV+CF)
hist(L,nclass=10)
contagem = ifelse(L<0,1,0)
sum(contagem)
prob_negativo = sum(contagem)/length(L)
prob_negativo
setwd("/Users/raphaelalbino/Dropbox/ead-5917/trabalho_disciplina/")
nba_data <- read.csv("dados_nba_2016_2006.csv")
# Effective field goal percentage
# EFG = (FGM + 0.5 ?? 3PM)/FGA
nba_data$effective_field_goal_percentage <- nba_data$effective_field_goal_percentage/100
nba_data$opponent_effective_field_goal_percentage <- nba_data$opponent_effective_field_goal_percentage/100
# Free throw rate
# FTR = FTM/FGA
# Turnovers per possession
# TPP = TO/POSS
# POSS = FGAt+0.44??FTAt???OREBt+TOt (formula to calculate possession)
nba_data$turnover_percentage <- nba_data$turnover_percentage/100
nba_data$opponent_turnover_percentage <- nba_data$opponent_turnover_percentage/100
# Offensive rebounding percentage
# ORP = OREBt /(OREB t+ DREBo)
nba_data$offensive_rebound_percentage <- nba_data$offensive_rebound_percentage/100
nba_data$opponent_offensive_rebound_rate <- nba_data$opponent_offensive_rebound_rate/100
# Estatística descritiva
summary(nba_data$win_percentage)
hist(nba_data$win_percentage, ylab="Frequencia",main="Histograma do percentual de vitorias", xlab="Percentual de vitorias")
boxplot(nba_data$win_percentage)
# Análise da dispersão das variáveis independentes quando cruzadas com o percentual de vitória (variável dependente)
par(mfrow=c(2,2))
plot(nba_data$win_percentage,nba_data$effective_field_goal_percentage,cex=0.1,pch=19,col="blue")
plot(nba_data$win_percentage,nba_data$free_throw_attempt_rate,cex=0.1,pch=19,col="blue")
plot(nba_data$win_percentage,nba_data$turnover_percentage,cex=0.1,pch=19,col="blue")
plot(nba_data$win_percentage,nba_data$offensive_rebound_percentage,cex=0.1,pch=19,col="blue")
par(mfrow=c(2,2))
plot(nba_data$win_percentage,nba_data$opponent_effective_field_goal_percentage,cex=0.1,pch=19,col="red")
plot(nba_data$win_percentage,nba_data$opponent_free_throw_attempted_rate,cex=0.1,pch=19,col="red")
plot(nba_data$win_percentage,nba_data$opponent_turnover_percentage,cex=0.1,pch=19,col="red")
plot(nba_data$win_percentage,nba_data$opponent_offensive_rebound_rate,cex=0.1,pch=19,col="red")
cor.test(nba_data$win_percentage,nba_data$effective_field_goal_percentage)
cor.test(nba_data$win_percentage,nba_data$free_throw_attempt_rate)
cor.test(nba_data$win_percentage,nba_data$turnover_percentage)
cor.test(nba_data$win_percentage,nba_data$offensive_rebound_percentage)
cor.test(nba_data$win_percentage,nba_data$opponent_effective_field_goal_percentage)
cor.test(nba_data$win_percentage,nba_data$opponent_free_throw_attempted_rate)
cor.test(nba_data$win_percentage,nba_data$opponent_turnover_percentage)
cor.test(nba_data$win_percentage,nba_data$opponent_offensive_rebound_rate)
par(mfrow=c(1,1))
regressao  <- lm(nba_data$win_percentage ~ nba_data$effective_field_goal_percentage + nba_data$free_throw_attempt_rate + nba_data$turnover_percentage + nba_data$offensive_rebound_percentage + nba_data$opponent_effective_field_goal_percentage+ nba_data$opponent_free_throw_attempted_rate+ nba_data$opponent_turnover_percentage+ nba_data$opponent_offensive_rebound_rate)
summary(regressao)
anova(regressao)
# Teste de distribuição normal dos erros
shapiro.test(residuals(regressao))
# Suposição erros possuem variância constante, se p-value maior do que 0.05 não se pode negar a hipótese nula, longo não há evidências de falta de homocedasticidade.
qqnorm(residuals(regressao), ylab="Resíduos",xlab="Quantis teóricos",main="")
qqline(residuals(regressao))
median(nba_data$win_percentage)
var.test(residuals(regressao)[nba_data$win_percentage<=0.503],residuals(regressao)
[nba_data$win_percentage>=0.503])
# modelagem de equações estruturais
# carregando a biblioteca de análise de componentes principais
library("plsdepot")
# qualidade ofensiva
qualidade_ofensiva <- data.frame(nba_data[,c(9,10,13,22)])
pca_ofensivo = nipals(qualidade_ofensiva)
plot(pca_ofensivo, main = "Indicadores de qualidade ofensiva", cex.main = 1)
# qualidade defensiva
qualidade_defensiva <- data.frame(nba_data[,c(58,59,60,61)])
pca_defensivo = nipals(qualidade_defensiva)
plot(pca_defensivo, main = "Indicadores de qualidade defensiva", cex.main = 1)
# ataque e defesa influenciam o percentual de vitória da equipe
library(plspm)
# construindo o modelo
Ataque = c(0, 0, 0)
Defesa = c(0, 0, 0)
Sucesso = c(1, 1, 0)
nba_path = rbind(Ataque, Defesa, Sucesso)
colnames(nba_path) = rownames(nba_path)
# exibindo o modelo
innerplot(nba_path)
nba_data$oturnovers <- -1 * nba_data$turnovers
# outer model
nba_blocks = list(c(9,10,13,22), c(58,59,60,61), 7)
# modes (reflective blocks)
nba_modes = rep("A", 3)
nba_teste <- nba_data[nba_data$year>=2012,]
nba_modelo <- nba_data[nba_data$year<=2011,]
nba_pls_teste = plspm(nba_teste, nba_path, nba_blocks, modes = nba_modes,boot.val = TRUE, br = 2000)
nba_pls_modelo = plspm(nba_modelo, nba_path, nba_blocks, modes = nba_modes,boot.val = TRUE, br = 2000)
nba_pls_teste$unidim
nba_pls_modelo$unidim
nba_pls_teste$outer_model
nba_pls_modelo$outer_model
nba_pls_teste$crossloadings
nba_pls_modelo$crossloadings
plot(nba_pls_teste, what = "loadings")
plot(nba_pls_modelo, what = "loadings")
nba_pls_teste$inner_summary
nba_pls_modelo$inner_summary
nba_pls_teste$gof
nba_pls_modelo$gof
nba_pls_teste$boot$paths
nba_pls_modelo$boot$paths
median(nba_data$effective_field_goal_percentage)
median(nba_data$free_throw_attempt_rate)
median(nba_data$turnover_percentage)
median(nba_data$offensive_rebound_percentage)
median(nba_data$opponent_effective_field_goal_percentage)
median(nba_data$opponent_free_throw_attempted_rate)
median(nba_data$opponent_turnover_percentage)
median(nba_data$opponent_offensive_rebound_rate)
median(nba_data$effective_field_goal_percentage)
var.test(residuals(regressao)[nba_data$effective_field_goal_percentage<=0.498],residuals(regressao)
[nba_data$effective_field_goal_percentage>=0.498])
median(nba_data$free_throw_attempt_rate)
var.test(residuals(regressao)[nba_data$free_throw_attempt_rate<=0.2885],residuals(regressao)
[nba_data$free_throw_attempt_rate>=0.2885])
median(nba_data$turnover_percentage)
var.test(residuals(regressao)[nba_data$turnover_percentage<=0.1495],residuals(regressao)
[nba_data$turnover_percentage>=0.1495])
median(nba_data$offensive_rebound_percentage)
var.test(residuals(regressao)[nba_data$offensive_rebound_percentage<=0.2595],residuals(regressao)
[nba_data$offensive_rebound_percentage>=0.2595])
median(nba_data$opponent_effective_field_goal_percentage)
var.test(residuals(regressao)[nba_data$opponent_effective_field_goal_percentage<=0.5],residuals(regressao)
[nba_data$opponent_effective_field_goal_percentage>=0.5])
median(nba_data$opponent_free_throw_attempted_rate)
var.test(residuals(regressao)[nba_data$opponent_free_throw_attempted_rate<=0.286],residuals(regressao)
[nba_data$opponent_free_throw_attempted_rate>=0.286])
median(nba_data$opponent_turnover_percentage)
var.test(residuals(regressao)[nba_data$opponent_turnover_percentage<=0.149],residuals(regressao)
[nba_data$opponent_turnover_percentage>=0.149])
median(nba_data$opponent_offensive_rebound_rate)
var.test(residuals(regressao)[nba_data$opponent_offensive_rebound_rate<=0.259],residuals(regressao)
[nba_data$opponent_offensive_rebound_rate>=0.259])
